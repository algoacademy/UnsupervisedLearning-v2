---
title: "Unsupervised Learning Quiz"
author: "Team Algoritma"
date: "`r format = Sys.Date('%e, %B %Y')`"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: false
    theme: united
    highlight: zenburn
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(FactoMineR)
library(factoextra)
```

Kuis ini merupakan bagian dari proses penilaian *Algoritma Academy*. Selamat anda sudah menyelesaikan materi *Unsupervised Learning*! Kami akan melakukan penilaian berupa kuis untuk menguji materi yang sudah dipelajari. Pengerjaan Kuis diharapkan dapat dilakukan di dalam kelas, silakan hubungi tim instruktur kami jika Anda melewatkan kesempatan untuk mengambilnya di kelas.

# Data Exploration

Pada kuis ini, kita akan menggunakan data **Fruits-Nutritional Values**. Anda bisa mendapatkan file csv yang tersimpan dalam folder ini dengan nama `fruits.csv`. Sebelum kita melakukan analisis clustering dan *principle component analysis*, kita perlu melakukan eksplorasi data. anda dapat melihat sekilas struktur dari dataset yang digunakan! Anda dapat menggunakan fungsi `str()` atau `glimpse()`. 

```{r}
# your code here

```

Dataset ini terdiri dari 21 variabel dengan 52 baris yang berisi komposisi nutrisi pada buah. Variabel berisi nama buah, dan variabel lainnya menjelaskan komposisi setiap elemen pada buah.

Variabel nama menggambarkan nama buah. Oleh karena itu, sebaiknya kita simpan isi kolom `nama` menjadi nama baris (rownames) dari data. Kita juga akan melihat jumlah observasi yang memuat nilai NA dari seluruh observasi, jika jumlah nilai yang hilang kurang dari 10% observasi, maka kita akan menghilangkan observasi yang memiliki nilai yang hilang.

```{r}
# your code here

```

# 1. Principal Component Analysis (PCA)

## Data Pre-Processing

PCA sangat berguna untuk menyimpan informasi sekaligus mereduksi dimensi data. Namun, kita perlu memastikan bahwa data sudah diskalakan (*scaled*) dengan benar untuk mendapatkan PCA yang berguna. Anda dapat menggunakan fungsi `scale()` untuk malakukan normalisasi/standarisasi skala dari variabel numerik dan menyimpannya sebagai `fruits_scale`.

```{r}
# your code here

```

## Build your Principal Component

Kita telah menyiapkan data yang sudah distandarisasi untuk digunakan pada PCA. Selanjutnya, kita akan mencoba membuat *principal component* dari `fruits_scale`. Ingat kembali bagaimana kita menggunakan *library* `FactoMineR` untuk melakukan PCA. Gunakan fungsi `PCA()` dari library tersebut untuk menghasilkan PCA dan menyimpannya sebagai `pca_fruits`. Ingatlah untuk mengatur parameter `scale.unit` ke` FALSE` karena kita sudah melakukan standarisasi data secara manual. Periksa ringkasan dari `pca_fruits`.

```{r}
# your code here

```

1. Berdasarkan hasil ringkasan (*summary*), berapa banyak *Principal Components* (PCs) yang akan anda gunakan bila anda hanya mentoleransi informasi yang hilang tidak lebih dari 20%.
 - [ ] 7 PC (PC 1 sampai 7)
 - [ ] 5 PC (PC 1 sampai 5)
 - [ ] 3 PC (PC 1 sampai 3)
 - [ ] 1 PC (PC 1 saja)
 
Implementasi lainnya yang sangat menarik adalah memvisualisasikan data berdimensi tinggi menjadi plot 2 dimensi untuk berbagai tujuan, seperti analisis cluster atau mendeteksi pencilan. Untuk memvisualisasikan PCA, gunakan fungsi `plot.PCA()` ke `pca_fruits` dan tampilkan 2 observasi yang memiliki kontribusi paling besar. Ini akan menghasilkan plot PCA individu.

```{r}
# your code here

```

2. Berdasarkan plot yang sudah Anda buat, buah apa yang dianggap outlier?
 - [ ] Avocado, Dates deglet noor
 - [ ] Avocado, Lime
 - [ ] Kumquat, Pear
 - [ ] Guava, Pear

Kita juga dapat membuat plot PCA variabel yang menunjukkan *loading information* setiap variabel dari PCA hanya dengan menambahkan `choix ="var "` di `plot.PCA ()`. *loading information* akan diwakili oleh panjang panah dari pusat koordinat. Semakin panjang panahnya, semakin besar *loading information* dari variabel tersebut. Namun, ini mungkin bukan metode yang efisien jika kita memiliki banyak fitur. Beberapa variabel akan tumpang tindih satu sama lain, sehingga lebih sulit untuk melihat nama variabel.

Cara alternatif untuk mengekstrak *loading information* adalah dengan menggunakan fungsi `dimdesc()` ke `pca_fruits`. Simpan hasilnya sebagai `pca_dimdesc`. Periksa *loading information* dari dimensi/PC pertama  dengan memanggil `pca_dimdesc$Dim.1` karena dimensi pertama adalah PC yang merangkum informasi paling banyak.

```{r}
# your code here

```

3. Sebutkan 3 variabel yang paling berkontribusi pada PC 1 berdasarkan korelasi antar variabel dengan PC 1.
 - [ ] Potassium, Phosphorus, Vitamin B2
 - [ ] Magnessium, Vitamin B3, Fiber
 - [ ] Magnessium, Potassium, Phosphorus
 - [ ] Water, Vitamin E, Fiber
 - [ ] Acidity, Body, Balance

Dalam *principal component analysis*, setiap PC yang dihasilkan memiliki nilai eigen yang diperoleh dari matriks kovarians. Semakin besar nilai eigen, semakin besar varian yang ditangkap oleh PC.

4. Manakah dari pernyataan berikut ini yang **TIDAK BENAR** tentang PCA?

 - [ ] PCA membutuhkan data yang sudah diskalakan agar tiap variabel memiliki rentang nilai yang sama
 - [ ] Sebuah *Principal Component* (PC) dengan eigenvalue 0.6 tidak lebih membantu dibandingkan PC dengan eigenvalue 6.0
 - [ ] Kita tidak dapat merekonstruksi data awal kita secara sempurna dari hasil PCA meskipun kita memiliki eigen value dan eigen vector

*Referensi Opsi Bahasa Inggris:*
 - [ ] PCA requires data to be scaled so they have the same range of measurement
 - [ ] A Principal Component with an eigenvalue of 0.6 is not more helpful than a PC with an eigenvalue of 6.0
 - [ ] We cannot fully reconstruct the original data from a PCA even when we have eigen value and eigen vector

# 2. K-Means Clustering

Pengelompokan data (*Data Clustering*) adalah teknik data mining yang umum untuk membuat kelompok data yang dapat diidentifikasi sebagai "data dengan karakteristik yang sama". Sebelum melakukan pengelompokan data, Anda perlu menghapus *outlier* yang teridentifikasi berdasarkan plot PCA individu sebelumnya. Observasi buah `Avocado` dan `Dates, deglet noor` adalah pencilan yang cukup meluas dibandingkan dengan pengamatan lainnya. Hapus observasi tersebut dari dataset awal kita dan sekali lagi lakukan penskalakan (*scaling*) data.

*Note: Anda mungkin ingin menyimpan data yang sudah diskalakan ke objek baru karena kita masih memerlukan data asli untuk analisis profil cluster nanti.* 

```{r}
# your code here

```

## 2.1 Choosing Optimum K

Langkah selanjutnya dalam membangun cluster dengan K-means adalah menemukan jumlah cluster optimal untuk memodelkan data kita. Gunakan fungsi `kmeansTunning()` yang disediakan di bawah ini untuk menemukan K yang optimal menggunakan metode Elbow. Gunakan maksimum `maxK` sebesar 5 untuk membatasi plot menjadi 5 cluster berbeda.

```{r message=F, warning=F}
RNGkind(sample.kind = "Rounding")
kmeansTunning <- function(data, maxK) {
  withinall <- NULL
  total_k <- NULL
  for (i in 1:maxK) {
    set.seed(101)
    temp <- kmeans(data,i)$tot.withinss
    withinall <- append(withinall, temp)
    total_k <- append(total_k,i)
  }
  plot(x = total_k, y = withinall, type = "o", xlab = "Number of Cluster", ylab = "Total within")
}

# kmeansTunning(your_data, maxK = 5)

```

Kita akan memilih titik dimana penurunan WSS sudah tidak lagi signifikan (melandai). Berdasarkan hasil *elbow plot* kita akan memilih nilai k = 2.

K-means merupakan algoritma clustering yang mengelompokkan data berdasarkan jarak. Cluster yang dihasilkan dikatakan optimal jika jarak antar data pada cluster yang sama rendah dan jarak antar data dari cluster yang berbeda tinggi.

5. Manakah dari pernyataan berikut yang **TIDAK BENAR** tentang pemilihan jumlah cluster?

  - [ ] Semakin besar jumlah cluster mengindikasikan cluster semakin baik
  - [ ] Pemilihan jumlah cluster bisa berdasarkan perspektif bisnis
  - [ ] Lokasi *elbow* pada *elbow plot* dianggap sebagai indikator jumlah cluster yang baik
  - [ ] Elbow method membandingkan `total within sum of squares` untuk nilai k yang berbeda
  
*Referensi Opsi Bahasa Inggris:*  
  - [ ] A high number of clusters indicates a good clustering
  - [ ] Choosing the number of clusters can be based on a business perspective
  - [ ] The location of an *elbow* in Elbow Curve is generally considered as an indicator of the appropriate number of clusters
  - [ ] Elbow method compares the total within sum of square variation from different values of k 

6. Manakah dari pernyataan berikut ini yang **TIDAK BENAR** tentang K-Means?

  - [ ] Centroid (titik pusat cluster) pada iterasi pertama dipilih secara acak
  - [ ] Cluster yang baik memiliki nilai `withinss` yang rendah dan `betweenss` yang tinggi
  - [ ] Cluster dengan nilai `withinss` yang rendah berarti memiliki data dengan karakteristik yang mirip di dalam 1 cluster
  - [ ] Semakin tinggi nilai `betweenss` mengindikasikan variansi data yang tinggi di dalam setiap cluster
  
*Referensi Opsi Bahasa Inggris:*  
  - [ ] The centroid in the first iteration is placed randomly
  - [ ] A good cluster are clusters with low `withinss` and high `betweenss`
  - [ ] Cluster with low `withinss` means the character of the data within 1 cluster are similar to each other
  - [ ] The greater the value of `betweenss`, indicates the greater the data variance in each cluster

## 2.2 Building Cluster

Setelah Anda menemukan K optimal pada bagian sebelumnya, coba lakukan K-means *clustering*  dari data Anda dan simpan sebagai `fruits_cluster`. Gunakan `set.seed (101)` untuk menjamin contoh yang dapat direproduksi. Ekstrak informasi cluster dari objek K-means yang dihasilkan menggunakan `fruits_cluster$cluster` dan tambahkan sebagai kolom baru bernama` cluster` ke dataset `fruits`.

```{r}
# your code here
RNGkind(sample.kind = "Rounding")
set.seed(101)


```

## 2.3 Clusters Profiling

Anda dapat menggunakan *chunk* berikut untuk menjawab pertanyaan nomor 7.

```{r}
# your code here

```

7. Untuk pelanggan yang menikmati buah `Apricot`, manakah dari buah berikut yang mungkin cukup mirip untuk direkomendasi?
  - [ ] Kumquat
  - [ ] Banana
  - [ ] Apple

Ingat bahwa kita dapat melakukan profilisasi cluster dengan menggunakan kombinasi `group_by()` dan `summarise_all()`, yang dikelompokkan berdasarkan kolom cluster yang telah dibuat sebelumnya. Setelah Anda mengekstrak karakteristik untuk setiap cluster, coba jawab pertanyaan berikut:

```{r}
# your code here

```

8. Bisakah Anda mendeskripsikan karakteristik buah yang ada di cluster yang sama dengan `Mango`!

  - [ ] Nilai rata-rata protein terendah, nilai rata-rata `vitamin_e` tertinggi, dan nilai rata-rata `sugars` tertinggi
  - [ ] Nilai rata-rata protein terendah, nilai rata-rata `fiber` tertinggi, dan nilai rata-rata `iron_mg` terendah
  - [ ] Nilai rata-rata protein terendah, nilai rata-rata `water` tertinggi, dan nilai rata-rata `vitamin_a_iu` tertinggi
  - [ ] Nilai rata-rata protein terendah, nilai rata-rata `calcium_mg` terendah, dan nilai rata-rata `sugars` tertinggi
  
*Referensi Opsi Bahasa Inggris:*
  - [ ] Lowest mean of protein, highest mean of vitamin E, and highest mean of sugars
  - [ ] Lowest mean of protein, highest mean of fiber, and lowest mean of iron_mg
  - [ ] Lowest mean of protein, highest mean of water, and highest mean of vitamin_a_iu
  - [ ] Lowest mean of protein, lowest mean of calcium_mg, and highest mean of sugars